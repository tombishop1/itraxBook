# Transforming Data
The XRF data typically reported from the Itrax core scanner come from the spectral processing software Q-Spec. The output is usually in the form of an intensity, which is a dimensionless metric derived from the size of the spectral peak for a particular element, above the  background Bremsstrahlung radiation, sometimes normalised for the tube current and/or counting time. 

## Ratios and Normalisation
These data are compositional, and represent the changes in the relative proportions of all components of the matrix, measured and un-measured. As such it is likely the data will need transforming for certain types of multivariate analysis. As previously mentioned, these data are dimensionless, and as such do not represent a quantity, but are directly related to the absolute amount of a particular element in the matrix. It is often the case that ratios of elements are used to represent changes in composition --- this is sometimes referred to as normalisation, or normalising one element against another. 

It is trivial to calculate element ratios, to the extent that these can often simply be calculated where they are required rather than saving them to memory. For example, if a plot of the Compton divided by the Rayleigh scatter was desired, there is no need to save the computed value to a new variable (e.g. `coh_inc <- df$Mo.coh/df$Mo.inc`) --- simply define the calculation during plotting. To calculate ratios for all elements at once, use `mutate(across(any_ofelementsList))`, where `elementsList` is a list of chemical elements extracted from `data(PeriodicTable)`.

```{r divide_by_inc}
CD166_19_xrf %>%
  mutate(across(any_of(elementsList)) /`Mo inc`) %>%
  head()
```

## Running Mean and Other Window Functions

Where a signal is noisy but appears to exhibit some signal it may be appropriate to use a running mean to "smooth" the signal. However, considerable caution should be exercised in the use of this tool. It is rare for an analysis to be genuinely improved by the use of running means, although it can artificially improve statistics for some tests. When visualising data using a running mean the original, unmodified data should always be shown alongside to avoid any misunderstanding. This method can be used for any suitable window function (e.g. `min()`, `max()`, `range()` and `sd`.)

```{r warning=FALSE}
CD166_19_xrf %>%
  # uses a 50 point running mean (50 mm for this data); 25 before, 25 after
  mutate(across(any_of(elementsList), 
                function(x){unlist(slider::slide(x, mean, .before = 25, .after = 25))}
                )
         ) %>%
  ggplot(mapping = aes(x = depth, y = Ca)) + 
  geom_line(data = CD166_19_xrf, col = "grey80") + 
  geom_line() + 
  scale_x_reverse() +
  theme_paleo()
```

To plot the running means in a stratigraphic diagram, the smoothed data has to be labelled and combined with the original data so it can be facetted.

```{r message=FALSE}
# make the xrf plot with running means
full_join(y = CD166_19_xrf %>%
                        as_tibble() %>%
                        # uses a 50 point running mean (50 mm for this data); 25 before, 25 after
                        mutate(across(any_of(c(elementsList)), 
                                      function(x){unlist(slider::slide(x, mean, .before = 25, .after = 25))}
                                      )
                               ) %>%
                        mutate(type = "mean"), 
                      x = CD166_19_xrf %>% 
                        as_tibble() %>% 
                        mutate(type = "raw")
                      ) %>% 
  filter(validity == TRUE) %>%
  select(Fe, Ti, Cu, Pb, Si, MSE, Mn, depth, label, type) %>%
  tidyr::pivot_longer(!c("depth", "label", "type"), names_to = "elements", values_to = "peakarea") %>% 
  tidyr::drop_na() %>%
  mutate(elements = factor(elements, levels = c("MSE", elementsList))) %>%
  glimpse() %>%
  mutate(label = as_factor(label),
         type = as_factor(type)
         ) %>%
  
  ggplot(aes(x = peakarea, y = depth)) +
  tidypaleo::geom_lineh(aes(colour = type)) +
  scale_colour_manual(values = rev(c("black", "grey50"))) +
  scale_y_reverse() +
  scale_x_continuous(n.breaks = 2) +
  facet_geochem_gridh(vars(elements)) +
  labs(x = "peak area", y = "Depth [mm]") +
  tidypaleo::theme_paleo() +
  theme(legend.position = "none",
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```

## Preparing Data for Multivariate Data Analysis
Where multivariate methods (cluster analysis, principle components analysis, correlation matrices) are required, it is usually necessary to transform data. This is because the statistical assumptions that underlie these methods are often not met when dealing with compositional data like that from an XRF core-scanner. There is no "right" or ideal way to deal with these issues, but a common method is to use a form of log transformation. Here we use a centred log transformation, which cannot be performed on zero values. 

```
df %>% chemometrics::clr(df)
```

There are a number of possible solutions to this problem of zero values, none ideal, but the most common are to add an arbitrary number to the entirety of the data, or to replace zero values with a very small number, perhaps the limit of precision or the limit of detection. In the example shown, the limit of precision for the peak area intensity or counts is used (`0.001` or `1` respectively). 

```
input[input == 0] <- 0.001
```

A final solution may be to exclude zero values from any subsequent analysis, although not all methods tolerate `NA` in the data. Where there are many zero values for a particular variable, the variable may not provide good data and could be excluded. 

```
df %>% na_if(0)
```

In most multivariate analyses there are a number of variables which have high signal-to-noise ratios or otherwise only add noise to multivariate methods. In these cases, they might be excluded from multivariate methods. The selection of variables for inclusion is a matter for the analyst. It goes without saying that variables that are not part of the composition (that is, anything that is not an element) must be removed from the data used for multivariate analysis.

```
df %>% select(-any_of(c("Mg", "Co", "Mo"))
```

Finally, in order to correctly identify the measurements to their original data source, it is necessary to use row names that uniquely identify observations. For single scans this is not usually an issue --- the `depth` or `position` variable can be used. However, where a dataset is a composition of multiple cores, you may find that there are multiple observations for a particular depth where cores overlap. In the example shown we create a unique name for each observation by concatenating the name of the core as recorded in the `label` column of a core sequence joined using `itraxR::itrax_join()` with the corresponding `depth` variable, but the code could be modified to suit a different work flow. 

```
rowlabels <- str_c(df$label, df$depth, sep = "_")
input <- df %>% select(any_of(elements)) 
input <- input %>% select(-any_of(c("Mg", "Co", "Mo")))
input[input == 0] <- 0.001

library(chemometrics)
input <- clr(input)

row.names(input) <- rowlabels
```
