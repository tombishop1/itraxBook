# Calibrating Data

Although much analysis can be done using the peak-area data from the Itrax, it may be desirable to attempt to fully quantify the data. Because of the variability typically encountered in palaeoenvironmental work a "fundamental parameters" type approach is not often possible, although there is some functionality for this in the `Q-Spec` software on the instrument. 

Rather, an empirical approach is usually required, whereby some subset of the material is sampled and a relationship (calibration curve) is calculated for analytes of interest. An empirical approach also has the benefit of being able to estimate the uncertainties of the calibration. 

## Suitable Methods

There are a number of published methods for quantifying elemental concentrations from ED-XRF data, and the area is of continued research interest. Most methods fall into the category of bivariate linear models of the relationship between ED-XRF peak area, and independently derived element concentrations (e.g. sub-samples analysed by ICP-MS). However, there are also more complex approaches, like Lee Drake's modern version of the Lucas-Tooth and Price (1961) algorithm, "CloudCal". 

## Preparing Data

In order to perform empirical calibration it is necessary to have some quantitative data that relates directly to the Itrax XRF data. The quantitative data is unlikely to be at the same resolution as the Itrax XRF data. For example, it is typical to scan cores at between 0.2 and 1 mm, but typical to sub-sample for WD-XRF or ICP at between 5 - 10 mm. In addition, where Itrax scans are contiguous, sub-samples may not be, for example a 10 mm sub-sample might be taken every 80 mm.

The function `itraxR::itrax_reduction()` can be used to reduce the data to match the resolution of some other data. The example below uses the hypothetical example of some determinations of Ti on sub-samples on the core sequence that are 10 mm in size, taken every 50 mm. Here is the hypothetical data:

```{r include=FALSE}
icp <- tibble(top = seq(from = min(CD166_19_xrf$depth), to = max(CD166_19_xrf$depth)-10, by = 10),
              bot = top + 10,
              Ti  = rnorm(length(top))
       ) %>%
  filter(row_number() %% 5 == 1) %>%
  mutate(SampleID = paste0("ICP_ID_", 1:length(top))) %>%
  select(SampleID, everything())
```

```{r}
glimpse(icp)
```

And here is the use of `itrax_reduce()` to reduce our Itrax XRF data (`CD166_19_xrf`), using the shape of the "icp" data (in `icp`). 

```{r message=FALSE, warning=FALSE}
xrf_icp <- CD166_19_xrf %>%
  drop_na() %>%
  select(-c(label, filename)) %>%
  itrax_reduce(names = icp$SampleID,
               breaks_lower = icp$top,
               breaks_upper = icp$bot) %>%
  select(resample_names, Ti) %>%
  rename(Ti_XRF = Ti,
         SampleID = resample_names) %>%
  
  inner_join(., icp, by = "SampleID") %>%
  select(SampleID, Ti, Ti_XRF, everything())

xrf_icp %>% glimpse()
```

Note the requirement to remove text based columns (in this case `file` and `label`) from the data before this step is performed - if the reducing function cannot handle a data type (e.g. passing characters to `mean()`), errors will occur. If we wanted to add the standard deviation alongside the mean for each chunk, this can be done my modifying the default reducing function (`mean()`) to `sd()`, for example:

```{r message=FALSE, warning=FALSE}
CD166_19_xrf %>%
  drop_na() %>%
  select(-c(label, filename)) %>%
  itrax_reduce(names = icp$SampleID,
               breaks_lower = icp$top,
               breaks_upper = icp$bot,
               fun = sd) %>%
  select(resample_names, Ti) %>%
  rename(Ti_XRF_sd = Ti,
         SampleID = resample_names) %>%
  inner_join(., xrf_icp, by = "SampleID") %>%
  select(SampleID, Ti, Ti_XRF, Ti_XRF_sd, everything()) %>%
  glimpse()
```

It is worth reading `?itraxR::itrax_reduce()` as the behaviour can and should be modified depending on your exact use case. For example, in th situation above where none of the samples are contiguous it might be wise to modify the parameters of `itraxR::itrax_reduce()` to include `edges = c(">=", "<=")` so that the "edges" of the sub-samples are captured. This might not be the case for contiguous samples in order to avoid "double-counting". 

```{r include=FALSE}
rm(icp, xrf_icp)
```

## Selecting Samples

Unless you plan on sub-sampling the entire core, perhaps contiguously, you will need to decide where best to take your samples for best model coverage. If you are only interested in a single element, this is trivial - simply ensure your sampling strategy encompasses a wide range of samples. However, where you are attempting to calibrate for many elements, developing an optimal sampling strategy manually can be difficult. 

The function below illustrates the use of cluster analysis in optimising the sampling regime. Because it is unrealistic to plan on accurately sub-sampling at the high-resolution of the data (in this case, 1 mm), we use `itrax_reduce()` to re sample the data to a lower resolution, in this case, 10 mm. 

The following `itrax_section()` performs an unconstrained cluster analysis, and also reports the central sample in each cluster. This could be considered the most representative of each cluster, and thus the suitable location for sampling. In the graph below, the black ticks created by `geom_rug()` are the suggested sampling locations.

```{r calib_optimisation, warning=FALSE}
CD166_19_xrf %>%
  filter(qc == TRUE) %>%
  itrax_reduce(by = 10) %>%
  mutate(uid = 1:length(uid)) %>% # we have to spoof uid here
  drop_na("depth") %>%
  itrax_section(divisions = 50, 
                elementsonly = c("Ti", "Al", "Fe", "Mn", "Mg", 
                                 "Ca", "Na", "K" , "P" , "Si", 
                                 "V" , "Cr", "Co", "Ni", "Cu", 
                                 "Zn", "Sr", "Nb", "Y" , "Zr", 
                                 "Ba", "La", "Ce")
  ) %>%
  
  ggplot(mapping = aes(x = depth, y = 1, fill = group)) + 
  geom_tile(width = 10) +
  scale_x_reverse() +
    geom_rug(sides = "b", 
             data = . %>% filter(calib_sample == TRUE)) +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        legend.position = "none") 
```

## Linear Methods

## Log-Ratio Methods
