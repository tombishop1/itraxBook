# Multivariate Methods

Input data often needs extensive preparation if useful results are to be obtained --- transformation, dealing with zero values, and `NA` values. It is worth mentioning some general issues around the robustness of multivariate analysis - special treatment is required for compositional data for most methods; see @Aitchison1986. 

At present the preparation of data is handled in `itraxR` using the internal function `itraxR:::multivariate_import()`, but at least at present this function is not exported from the package. However it can be accessed by the user using the `:::` notation. 

```{r}
data("periodicTable")
CD166_19_xrf %>%
  mutate(ids = 1:dim(CD166_19_xrf)[1]) %>%
  itraxR:::multivariate_import(elementsonly = TRUE, 
                               zeros = "addone", 
                               transform = TRUE) %>%
  glimpse()
```

## Correlation Coefficients

The Pearson's R correlation coefficient is occasionally used to study the relationships between individual elements. It is often useful in conjunction with principle component analysis.

```{r}
itrax_correlation(CD166_19_xrf) %>%
  ggcorrplot::ggcorrplot(hc.order = TRUE,
                         p.mat = ggcorrplot::cor_pmat(., method = "spearman"),
                         insig = "blank")
```

## Unconstrained Cluster Analysis

Unconstrained cluster analysis will group each measurement by similarity, returning an arbitrary number of groups as defined by the function. This is useful in identifying recurring compositional units, or identifying candidate samples for quantitative analysis. 

```{r}
itrax_section(CD166_19_S1$xrf, 
              elementsonly = c("Ti", "Si", "S", "K", "Ca"), divisions = 10) %>%
  pluck("groups") %>%

  ggplot() + 
  geom_tile(aes(x = depth, y = 1, fill = group)) +
  scale_x_reverse() +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())
```

Given that these groups form the characteristic compositional units, they present good candidates for sampling for quantitative analysis. The second part of this function will report the sample most characteristic of each group. For example, if you can submit 10 samples for quantitative analysis (e.g. ICP-MS), you can input the elements you wish to calibrate for in the `elementsonly` argument, the number of samples you want to take in the `divisions` argument, and the function will report the samples that are likely to give the best calibration across all elements. The resolution at which you are able to sub-sample the core may be significantly coarser than the scan, so you may wish to reduce the data first. The example below summarises the data into 50 mm chunks before the cluster analysis.

```{r}
foo <- CD166_19_xrf %>%
  select(where(is.numeric)) %>%
  itrax_reduce(by = 50) %>%
  itrax_section(elementsonly = c("Ti", "Si", "S", "K", "Ca"), divisions = 10)

ggplot() + 
  geom_tile(data = foo %>% pluck("groups"), 
            aes(x = depth, y = 1, fill = group, width = 50)) + # width here needs to be set to the resampling interval
  geom_point(data = foo %>% pluck("samples"), 
             aes(x = depth, y = 1)) +
  scale_x_reverse() +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())
```

```{r include=FALSE}
rm(foo)
```

## Constrained Cluster Analysis

## Principle Components Analysis
Principle components analysis can be used for exploring patterns in these data. 

```{r}
library(ggfortify)

CD166_19_xrf %>%
  itrax_ordination() %>%
  pluck("pca") %>%
  autoplot(loadings = TRUE, loadings.label = TRUE)
```

```{r}
CD166_19_xrf %>%
  itrax_ordination() %>%
  pluck("data") %>%
  select(depth, label, position, starts_with(".fittedPC")) %>%
  drop_na() %>%

  ggplot(aes(x = depth, y = .fittedPC1, colour = label)) +
  geom_line() + 
  scale_x_reverse()
```

